#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Analyze JSON backtest results.

This utility reads one or more JSON files generated by the backtest scripts
and outputs summary statistics. It can also display the trade list for
inspection.  With ``--by-side`` specified, summaries are printed
separately for long and short trades when the JSON data contains a
``side`` column.
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import List

import sys

import pandas as pd


PROFIT_COLUMNS = ["profit_jpy", "pnl_yen"]
RET_COLUMNS = ["ret_pct", "pnl_pct"]


def load_trades(paths: List[str]) -> pd.DataFrame:
    """Load trade records from JSON files and concatenate them."""
    frames = []
    for p in paths:
        df = pd.read_json(Path(p))
        frames.append(df)
    if not frames:
        return pd.DataFrame()
    return pd.concat(frames, ignore_index=True)


def _find_col(df: pd.DataFrame, candidates: List[str]) -> str:
    for c in candidates:
        if c in df.columns:
            return c
    raise ValueError("Required column not found")


def summarize(trades: pd.DataFrame) -> pd.DataFrame:
    """Calculate summary statistics from trade DataFrame."""
    if trades.empty:
        return pd.DataFrame()

    profit_col = _find_col(trades, PROFIT_COLUMNS)
    ret_col = _find_col(trades, RET_COLUMNS)

    total_profit = trades[profit_col].sum()
    win_rate = (trades[profit_col] > 0).mean()
    mean_ret_pct = trades[ret_col].mean()
    sharpe = trades[ret_col].mean() / trades[ret_col].std(ddof=0)

    return pd.DataFrame(
        {
            "metric": [
                "trades",
                "total_profit",
                "win_rate",
                "avg_ret_pct",
                "sharpe",
            ],
            "value": [len(trades), total_profit, win_rate, mean_ret_pct, sharpe],
        }
    )


def format_summary(summary: pd.DataFrame) -> pd.DataFrame:
    """Return human friendly formatted summary table."""
    if summary.empty:
        return summary

    def fmt(metric: str, value: float) -> str:
        if metric == "total_profit":
            return f"{value:,.0f} JPY"
        if metric in {"win_rate", "avg_ret_pct"}:
            return f"{value * (100 if metric == 'win_rate' else 1):.2f}%"
        if metric == "sharpe":
            return f"{value:.2f}"
        return f"{int(value)}"

    formatted = summary.copy()
    formatted["value"] = [
        fmt(m, v) for m, v in zip(summary["metric"], summary["value"])
    ]
    return formatted


def _ascii_bar_chart(values: List[float], width: int = 40) -> str:
    if not values:
        return ""
    max_v = max(abs(v) for v in values) or 1
    lines = []
    for i, v in enumerate(values, 1):
        bar = "#" * int(abs(v) / max_v * width)
        sign = "" if v >= 0 else "-"
        lines.append(f"{i:>3} {sign}{bar} ({v:+.0f})")
    return "\n".join(lines)


def _ascii_table(df: pd.DataFrame, heavy: bool = False) -> str:
    """Return a simple ASCII table.

    If ``heavy`` is ``True`` box drawing characters with heavier lines are used
    for better visibility.  When those characters cannot be encoded by the
    current output encoding, the function falls back to plain ASCII
    characters.
    """

    cols = list(df.columns)
    widths = [max(len(str(v)) for v in [c] + df[c].astype(str).tolist()) for c in cols]

    # Determine which characters to use for drawing.  Heavy box drawing
    # characters improve readability but are not available in all encodings,
    # notably the Windows ``cp932`` encoding.  In such cases we silently
    # fall back to simple ASCII characters.
    if heavy:
        try:
            "═╬║".encode(sys.stdout.encoding or "utf-8")
            h, v, c = "═", "║", "╬"
        except Exception:
            heavy = False

    if not heavy:
        h, v, c = "-", "|", "+"

    def border() -> str:
        return c + c.join(h * (w + 2) for w in widths) + c

    lines = [border()]
    header = v + v.join(f" {cname.ljust(w)} " for cname, w in zip(cols, widths)) + v
    lines.append(header)
    lines.append(border())
    for _, row in df.iterrows():
        line = (
            v
            + v.join(f" {str(row[cname]).rjust(w)} " for cname, w in zip(cols, widths))
            + v
        )
        lines.append(line)
        lines.append(border())
    return "\n".join(lines)


def main(argv: List[str] | None = None) -> None:
    ap = argparse.ArgumentParser(description="Backtest JSON analyzer")
    ap.add_argument("files", nargs="+", help="JSON files to analyze")
    ap.add_argument(
        "--show-trades",
        action="store_true",
        help="print trade table as well",
    )
    ap.add_argument(
        "--by-side",
        action="store_true",
        help="summarize long and short trades separately (requires 'side' column)",
    )
    args = ap.parse_args(argv)

    trades = load_trades(args.files)
    if trades.empty:
        print("No trades loaded.")
        return

    summary = summarize(trades)
    summary = format_summary(summary)
    print("=== Summary ===")
    for metric, value in zip(summary["metric"], summary["value"]):
        print(f"{metric:>12}: {value}")

    if args.by_side and "side" in trades.columns:
        for side in ["long", "short"]:
            sub = trades[trades["side"] == side]
            if sub.empty:
                continue
            s = format_summary(summarize(sub))
            print(f"\n=== {side.capitalize()} Summary ===")
            for metric, value in zip(s["metric"], s["value"]):
                print(f"{metric:>12}: {value}")

    if args.show_trades:
        print("\n=== Trades ===")
        # Use thicker borders for better readability
        print(_ascii_table(trades.reset_index(drop=True), heavy=True))
        profit_col = _find_col(trades, PROFIT_COLUMNS)
        print("\n=== Profit per Trade ===")
        chart = _ascii_bar_chart(trades[profit_col].tolist())
        print(chart)


if __name__ == "__main__":
    main()
